// RUN: %target-sil-opt -inline -verify %s | %FileCheck %s
// RUN: %target-sil-opt -mandatory-inlining -verify %s | %FileCheck %s

import Builtin
import Swift

sil @marker : $(Builtin.Int32) -> ()

class SomeClass {}
sil_vtable SomeClass {}

class SomeSubclass : SomeClass {}
sil_vtable SomeSubclass {}

// This is designed to be formally indirect.
struct Indirect<T: AnyObject> {
  var x: Any
  var y: T
}

sil @make_indirect : $<T: SomeClass> () -> (@out Indirect<T>)

sil [transparent] @test_one_yield : $@yield_once <C: SomeClass> () -> (@yields @in Indirect<C>) {
entry:
  %marker = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
  %1000 = integer_literal $Builtin.Int32, 1000
  apply %marker(%1000) : $@convention(thin) (Builtin.Int32) -> ()
  %temp = alloc_stack $Indirect<C>
  %make = function_ref @make_indirect : $@convention(thin) <T: SomeClass> () -> (@out Indirect<T>)
  apply %make<C>(%temp) : $@convention(thin) <T: SomeClass> () -> (@out Indirect<T>)
  yield %temp : $*Indirect<C>, resume resume, unwind unwind

resume:
  %2000 = integer_literal $Builtin.Int32, 2000
  apply %marker(%2000) : $@convention(thin) (Builtin.Int32) -> ()
  dealloc_stack %temp : $*Indirect<C>
  %ret = tuple ()
  return %ret : $()

unwind:
  %3000 = integer_literal $Builtin.Int32, 3000
  apply %marker(%3000) : $@convention(thin) (Builtin.Int32) -> ()
  dealloc_stack %temp : $*Indirect<C>
  unwind
}

// CHECK-LABEL: sil @test_simple_call
// CHECK: bb0(%0 : @trivial $Builtin.Int1):
// CHECK:  [[MARKER:%.*]] = function_ref @marker
// CHECK:  [[MARKER2:%.*]] = function_ref @marker
// CHECK:  [[I:%.*]] = integer_literal $Builtin.Int32, 1000
// CHECK:  apply [[MARKER2]]([[I]]) : $@convention(thin) (Builtin.Int32) -> ()
// CHECK:  [[TEMP:%.*]] = alloc_stack $Indirect<SomeSubclass>
// CHECK:  [[MK_IND:%.*]] = function_ref @make_indirect
// CHECK:  apply [[MK_IND]]<SomeSubclass>([[TEMP]])
// CHECK:  [[INTTOKEN:%.*]] = integer_literal $Builtin.Int32, 0
// CHECK:  br bb3([[INTTOKEN]] : $Builtin.Int32)

// CHECK:bb1:
// CHECK:  [[I2:%.*]] = integer_literal $Builtin.Int32, 2000
// CHECK:  apply [[MARKER2]]([[I2]])
// CHECK:  dealloc_stack [[TEMP]] : $*Indirect<SomeSubclass>
// CHECK:  br bb5

// CHECK: bb2:
// CHECK:  [[I3:%.*]] = integer_literal $Builtin.Int32, 3000
// CHECK:  apply [[MARKER2]]([[I3]])
// CHECK:  dealloc_stack [[TEMP]] : $*Indirect<SomeSubclass>
// CHECK:  br bb7

// CHECK: bb3([[WHICH_YIELD:%.*]] : @trivial $Builtin.Int32):
// CHECK:  destroy_addr [[TEMP]] : $*Indirect<SomeSubclass>
// CHECK:  cond_br %0, bb4, bb6

// CHECK: bb4:
// CHECK:   [[I4:%.*]] = integer_literal $Builtin.Int32, 10
// CHECK:   apply [[MARKER]]([[I4]])
// CHECK:   [[ZERO:%.*]] = integer_literal $Builtin.Int32, 0
// CHECK:   switch_value [[WHICH_YIELD]] : $Builtin.Int32, case [[ZERO]]: bb1

// CHECK: bb5:
// CHECK:   [[I5:%.*]] = integer_literal $Builtin.Int32, 20
// CHECK:   apply [[MARKER]]([[I5]])
// CHECK:  br bb8

// CHECK: bb6:
// CHECK:   [[I6:%.*]] = integer_literal $Builtin.Int32, 11
// CHECK:   apply [[MARKER]]([[I6]])
// CHECK:   [[ZERO:%.*]] = integer_literal $Builtin.Int32, 0
// CHECK:   switch_value [[WHICH_YIELD]] : $Builtin.Int32, case [[ZERO]]: bb2

// CHECK: bb7:
// CHECK:   [[I7:%.*]] = integer_literal $Builtin.Int32, 21
// CHECK:   [[MARKER]]([[I7]])
// CHECK:  br bb8

// CHECK:bb8:
// CHECK:  return
// CHECK:}

sil @test_simple_call : $(Builtin.Int1) -> () {
entry(%flag : @trivial $Builtin.Int1):
  %marker = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
  %0 = function_ref @test_one_yield : $@convention(thin) @yield_once <T: SomeClass> () -> (@yields @in Indirect<T>)
  (%value, %token) = begin_apply %0<SomeSubclass>() : $@convention(thin) @yield_once <T: SomeClass> () -> (@yields @in Indirect<T>)
  destroy_addr %value : $*Indirect<SomeSubclass>
  cond_br %flag, yes, no

yes:
  %10 = integer_literal $Builtin.Int32, 10
  apply %marker(%10) : $@convention(thin) (Builtin.Int32) -> ()
  end_apply %token
  %20 = integer_literal $Builtin.Int32, 20
  apply %marker(%20) : $@convention(thin) (Builtin.Int32) -> ()
  br cont

no:
  %11 = integer_literal $Builtin.Int32, 11
  apply %marker(%11) : $@convention(thin) (Builtin.Int32) -> ()
  abort_apply %token
  %21 = integer_literal $Builtin.Int32, 21
  apply %marker(%21) : $@convention(thin) (Builtin.Int32) -> ()
  br cont

cont:
  %ret = tuple ()
  return %ret : $()
}

sil [transparent] @test_two_yield : $@yield_once <C: SomeClass> (Builtin.Int1) -> (@yields @in Indirect<C>, @yields Builtin.Int64) {
entry(%0 : @trivial $Builtin.Int1):
  %marker = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
  %1000 = integer_literal $Builtin.Int32, 1000
  apply %marker(%1000) : $@convention(thin) (Builtin.Int32) -> ()
  %temp = alloc_stack $Indirect<C>
  %make = function_ref @make_indirect : $@convention(thin) <T: SomeClass> () -> (@out Indirect<T>)
  cond_br %0, yield1, yield2

yield1:
  apply %make<C>(%temp) : $@convention(thin) <T: SomeClass> () -> (@out Indirect<T>)
  %res = integer_literal $Builtin.Int64, 31
  yield (%temp : $*Indirect<C>, %res: $Builtin.Int64), resume resume1, unwind unwind1

yield2:
  apply %make<C>(%temp) : $@convention(thin) <T: SomeClass> () -> (@out Indirect<T>)
  %res2 = integer_literal $Builtin.Int64, 32
  yield (%temp : $*Indirect<C>, %res2: $Builtin.Int64), resume resume2, unwind unwind2

resume1:
  br resume
resume2:
  br resume

resume:
  %2000 = integer_literal $Builtin.Int32, 2000
  apply %marker(%2000) : $@convention(thin) (Builtin.Int32) -> ()
  dealloc_stack %temp : $*Indirect<C>
  %ret = tuple ()
  return %ret : $()

unwind1:
 br unwind
unwind2:
 br unwind

unwind:
  %3000 = integer_literal $Builtin.Int32, 3000
  apply %marker(%3000) : $@convention(thin) (Builtin.Int32) -> ()
  dealloc_stack %temp : $*Indirect<C>
  unwind
}

// We don't support inlining functions with multiple yields yet.
// CHECK-LABEL: sil @test_simple_call_two_yields : $@convention(thin) (Builtin.Int1, Builtin.Int1) -> () {
// CHECK: bb0(%0 : @trivial $Builtin.Int1, %1 : @trivial $Builtin.Int1):
// CHECK:   begin_apply
// CHECK:   return

sil @test_simple_call_two_yields : $(Builtin.Int1, Builtin.Int1) -> () {
entry(%flag : @trivial $Builtin.Int1, %flag2 : @trivial $Builtin.Int1):
  %marker = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
  %0 = function_ref @test_two_yield : $@convention(thin) @yield_once <T: SomeClass> (Builtin.Int1) -> (@yields @in Indirect<T>, @yields Builtin.Int64)
  (%value, %value2, %token) = begin_apply %0<SomeSubclass>(%flag) : $@convention(thin) @yield_once <T: SomeClass> (Builtin.Int1) -> (@yields @in Indirect<T>, @yields Builtin.Int64)
  destroy_addr %value : $*Indirect<SomeSubclass>
  cond_br %flag2, yes, no

yes:
  end_apply %token
  br cont

no:
  abort_apply %token
  br cont

cont:
  %ret = tuple ()
  return %ret : $()
}

// CHECK: sil @test_simple_call_yield_owned : $@convention(thin) (Builtin.Int1, @owned SomeClass) -> () {
// CHECK: bb0(%0 : @trivial $Builtin.Int1, %1 : @owned $SomeClass):
// CHECK:   %2 = function_ref @marker
// CHECK:   %3 = integer_literal $Builtin.Int32, 1000
// CHECK:   %4 = apply %2(%3)
// CHECK:   %5 = integer_literal $Builtin.Int32, 0
// CHECK:   br bb3(%1 : $SomeClass, %5 : $Builtin.Int32)

// CHECK: bb1:
// CHECK:   %7 = integer_literal $Builtin.Int32, 2000
// CHECK:   %8 = apply %2(%7)
// CHECK:   destroy_value %1 : $SomeClass
// CHECK:   br bb5

// CHECK: bb2:
// CHECK:   %12 = integer_literal $Builtin.Int32, 3000
// CHECK:   %13 = apply %2(%12)
// CHECK:   destroy_value %1 : $SomeClass
// CHECK:   br bb7

// CHECK: bb3(%16 : @owned $SomeClass, %17 : @trivial $Builtin.Int32):
// CHECK:   cond_br %0, bb4, bb6

// CHECK: bb4:
// CHECK:   %19 = integer_literal $Builtin.Int32, 0
// CHECK:   switch_value %17 : $Builtin.Int32, case %19: bb1

// CHECK: bb5:
// CHECK:   br bb8

// CHECK: bb6:
// CHECK:   %22 = integer_literal $Builtin.Int32, 0
// CHECK:   switch_value %17 : $Builtin.Int32, case %22: bb2

// CHECK: bb7:
// CHECK:   br bb8

// CHECK: bb8:
// CHECK:   %25 = tuple ()
// CHECK:   return %25 : $()

sil [transparent] @yield_owned : $@yield_once(@owned SomeClass) -> (@yields @owned SomeClass) {
entry(%0 : @owned $SomeClass):
  %marker = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
  %1000 = integer_literal $Builtin.Int32, 1000
  apply %marker(%1000) : $@convention(thin) (Builtin.Int32) -> ()
  yield %0 : $SomeClass, resume resume, unwind unwind

resume:
  %2000 = integer_literal $Builtin.Int32, 2000
  apply %marker(%2000) : $@convention(thin) (Builtin.Int32) -> ()
  destroy_value %0: $SomeClass
  %ret = tuple ()
  return %ret : $()

unwind:
  %3000 = integer_literal $Builtin.Int32, 3000
  apply %marker(%3000) : $@convention(thin) (Builtin.Int32) -> ()
  destroy_value %0: $SomeClass
  unwind
}

sil @test_simple_call_yield_owned : $(Builtin.Int1, @owned SomeClass) -> () {
entry(%flag : @trivial $Builtin.Int1, %c: @owned $SomeClass):
  %0 = function_ref @yield_owned : $@convention(thin) @yield_once(@owned SomeClass) -> (@yields @owned SomeClass)
  (%value, %token) = begin_apply %0(%c) : $@convention(thin) @yield_once(@owned SomeClass) -> (@yields @owned SomeClass)
  cond_br %flag, yes, no

yes:
  end_apply %token
  br cont

no:
  abort_apply %token
  br cont

cont:
  %ret = tuple ()
  return %ret : $()
}

sil @use : $@convention(thin) (@in Builtin.Int8) -> ()

sil [transparent] @yield_inout : $@yield_once() -> (@yields @inout Builtin.Int8) {
entry:
  %addr = alloc_stack $Builtin.Int8
  %8 = integer_literal $Builtin.Int8, 8
  store %8 to [trivial] %addr : $*Builtin.Int8
  yield %addr : $*Builtin.Int8, resume resume, unwind unwind

resume:
  %use = function_ref @use : $@convention(thin) (@in Builtin.Int8) -> ()
  apply %use(%addr) : $@convention(thin) (@in Builtin.Int8) -> ()
  dealloc_stack %addr: $*Builtin.Int8
  %ret = tuple ()
  return %ret : $()

unwind:
  %3000 = integer_literal $Builtin.Int32, 3000
  %marker = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
  apply %marker(%3000) : $@convention(thin) (Builtin.Int32) -> ()
  dealloc_stack %addr: $*Builtin.Int8
  unwind
}


// CHECK: sil @test_simple_call_yield_inout : $@convention(thin) (Builtin.Int1) -> () {
// CHECK: bb0(%0 : @trivial $Builtin.Int1):
// CHECK:   %1 = alloc_stack $Builtin.Int8
// CHECK:   %2 = integer_literal $Builtin.Int8, 8
// CHECK:   store %2 to [trivial] %1 : $*Builtin.Int8
// CHECK:   %4 = integer_literal $Builtin.Int32, 0
// CHECK:   br bb3(%4 : $Builtin.Int32)

// CHECK: bb1:
// CHECK:   %6 = function_ref @use : $@convention(thin) (@in Builtin.Int8) -> ()
// CHECK:   %7 = apply %6(%1) : $@convention(thin) (@in Builtin.Int8) -> ()
// CHECK:   dealloc_stack %1 : $*Builtin.Int8
// CHECK:   %9 = tuple ()
// CHECK:   br bb5

// CHECK: bb2:
// CHECK:   %11 = integer_literal $Builtin.Int32, 3000
// CHECK:   %12 = function_ref @marker : $@convention(thin) (Builtin.Int32) -> ()
// CHECK:   %13 = apply %12(%11) : $@convention(thin) (Builtin.Int32) -> ()
// CHECK:   dealloc_stack %1 : $*Builtin.Int8
// CHECK:   br bb7

// CHECK: bb3(%16 : @trivial $Builtin.Int32):
// CHECK:   cond_br %0, bb4, bb6

// CHECK: bb4:
// CHECK:   %18 = integer_literal $Builtin.Int8, 8
// CHECK:   store %18 to [trivial] %1 : $*Builtin.Int8
// CHECK:   %20 = integer_literal $Builtin.Int32, 0
// CHECK:   switch_value %16 : $Builtin.Int32, case %20: bb1

// CHECK: bb5:
// CHECK:   br bb8

// CHECK: bb6:
// CHECK:   %23 = integer_literal $Builtin.Int32, 0
// CHECK:   switch_value %16 : $Builtin.Int32, case %23: bb2

// CHECK: bb7:
// CHECK:   br bb8

// CHECK: bb8:
// CHECK:   %26 = tuple ()
// CHECK:   return %26 : $()
// CHECK: }

sil @test_simple_call_yield_inout : $(Builtin.Int1) -> () {
entry(%flag : @trivial $Builtin.Int1):
  %0 = function_ref @yield_inout : $@convention(thin) @yield_once() -> (@yields @inout Builtin.Int8)
  (%addr, %token) = begin_apply %0() : $@convention(thin) @yield_once() -> (@yields @inout Builtin.Int8)
  cond_br %flag, yes, no

yes:
  %8 = integer_literal $Builtin.Int8, 8
  store %8 to [trivial] %addr : $*Builtin.Int8
  end_apply %token
  br cont

no:
  abort_apply %token
  br cont

cont:
  %ret = tuple ()
  return %ret : $()
}
